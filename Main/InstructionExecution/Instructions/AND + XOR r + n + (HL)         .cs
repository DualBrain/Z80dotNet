// AUTOGENERATED CODE
//
// Do not make changes directly to this (.cs) file.
// Change AND + XOR r + n + (HL)         .tt instead.

namespace Konamiman.Z80dotNet
{
    public partial class Z80InstructionExecutor
    {
        /// <summary>
        /// The AND A instruction.
        /// </summary>
        private byte AND_A()
        {
            FetchFinished();

            var oldValue = Registers.A;
            var argument = Registers.A;
			var newValue = (byte)(oldValue & argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 1;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 4;
        }

        /// <summary>
        /// The XOR A instruction.
        /// </summary>
        private byte XOR_A()
        {
            FetchFinished();

            var oldValue = Registers.A;
            var argument = Registers.A;
			var newValue = (byte)(oldValue ^ argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 0;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 4;
        }

        /// <summary>
        /// The AND B instruction.
        /// </summary>
        private byte AND_B()
        {
            FetchFinished();

            var oldValue = Registers.A;
            var argument = Registers.B;
			var newValue = (byte)(oldValue & argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 1;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 4;
        }

        /// <summary>
        /// The XOR B instruction.
        /// </summary>
        private byte XOR_B()
        {
            FetchFinished();

            var oldValue = Registers.A;
            var argument = Registers.B;
			var newValue = (byte)(oldValue ^ argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 0;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 4;
        }

        /// <summary>
        /// The AND C instruction.
        /// </summary>
        private byte AND_C()
        {
            FetchFinished();

            var oldValue = Registers.A;
            var argument = Registers.C;
			var newValue = (byte)(oldValue & argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 1;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 4;
        }

        /// <summary>
        /// The XOR C instruction.
        /// </summary>
        private byte XOR_C()
        {
            FetchFinished();

            var oldValue = Registers.A;
            var argument = Registers.C;
			var newValue = (byte)(oldValue ^ argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 0;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 4;
        }

        /// <summary>
        /// The AND D instruction.
        /// </summary>
        private byte AND_D()
        {
            FetchFinished();

            var oldValue = Registers.A;
            var argument = Registers.D;
			var newValue = (byte)(oldValue & argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 1;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 4;
        }

        /// <summary>
        /// The XOR D instruction.
        /// </summary>
        private byte XOR_D()
        {
            FetchFinished();

            var oldValue = Registers.A;
            var argument = Registers.D;
			var newValue = (byte)(oldValue ^ argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 0;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 4;
        }

        /// <summary>
        /// The AND E instruction.
        /// </summary>
        private byte AND_E()
        {
            FetchFinished();

            var oldValue = Registers.A;
            var argument = Registers.E;
			var newValue = (byte)(oldValue & argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 1;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 4;
        }

        /// <summary>
        /// The XOR E instruction.
        /// </summary>
        private byte XOR_E()
        {
            FetchFinished();

            var oldValue = Registers.A;
            var argument = Registers.E;
			var newValue = (byte)(oldValue ^ argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 0;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 4;
        }

        /// <summary>
        /// The AND H instruction.
        /// </summary>
        private byte AND_H()
        {
            FetchFinished();

            var oldValue = Registers.A;
            var argument = Registers.H;
			var newValue = (byte)(oldValue & argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 1;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 4;
        }

        /// <summary>
        /// The XOR H instruction.
        /// </summary>
        private byte XOR_H()
        {
            FetchFinished();

            var oldValue = Registers.A;
            var argument = Registers.H;
			var newValue = (byte)(oldValue ^ argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 0;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 4;
        }

        /// <summary>
        /// The AND L instruction.
        /// </summary>
        private byte AND_L()
        {
            FetchFinished();

            var oldValue = Registers.A;
            var argument = Registers.L;
			var newValue = (byte)(oldValue & argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 1;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 4;
        }

        /// <summary>
        /// The XOR L instruction.
        /// </summary>
        private byte XOR_L()
        {
            FetchFinished();

            var oldValue = Registers.A;
            var argument = Registers.L;
			var newValue = (byte)(oldValue ^ argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 0;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 4;
        }

        /// <summary>
        /// The AND (HL) instruction.
        /// </summary>
        private byte AND_aHL()
        {
            FetchFinished();

            var oldValue = Registers.A;
			var argument = ProcessorAgent.ReadFromMemory(Registers.HL.ToUShort());
			var newValue = (byte)(oldValue & argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 1;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 7;
        }

        /// <summary>
        /// The XOR (HL) instruction.
        /// </summary>
        private byte XOR_aHL()
        {
            FetchFinished();

            var oldValue = Registers.A;
			var argument = ProcessorAgent.ReadFromMemory(Registers.HL.ToUShort());
			var newValue = (byte)(oldValue ^ argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 0;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 7;
        }

        /// <summary>
        /// The AND n instruction.
        /// </summary>
        private byte AND_n()
        {
			var argument = ProcessorAgent.FetchNextOpcode();
            FetchFinished();

            var oldValue = Registers.A;
			var newValue = (byte)(oldValue & argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 1;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 7;
        }

        /// <summary>
        /// The XOR n instruction.
        /// </summary>
        private byte XOR_n()
        {
			var argument = ProcessorAgent.FetchNextOpcode();
            FetchFinished();

            var oldValue = Registers.A;
			var newValue = (byte)(oldValue ^ argument);
            Registers.A = newValue;

            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
            Registers.HF = 0;
            Registers.PF = Parity[newValue];
            Registers.NF = 0;
			Registers.CF = 0;
            SetFlags3and5From(newValue);

            return 7;
        }

    }
}