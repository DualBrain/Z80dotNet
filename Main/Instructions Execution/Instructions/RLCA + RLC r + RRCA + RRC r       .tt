<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="_Utils.t4"#>
<#@ output extension=".cs" #>
<#AutoGeneratedCodeWarning(); #>

namespace Konamiman.Z80dotNet
{
    public partial class Z80InstructionExecutor
    {
<#  foreach (var instrType in new[] {"RLC", "RRC"}) {
    foreach (var regName in new[] {"A", "B", "C", "D", "E", "H", "L", "(HL)", ""}) {
        var isOldInstr = (regName == "");
        var oldInstrName = instrType + "A";
        var reg = isOldInstr ? "A" : regName;
        var isMemHL = (reg == "(HL)");
        var instrName = isOldInstr ? oldInstrName : instrType + " " + reg;
        var methodName = isOldInstr ? oldInstrName : instrType + "_" + (isMemHL ? "aHL" : reg); #>
		/// <summary>
        /// The <#=instrName #> instruction
        /// </summary>
        byte <#=methodName #>()
        {
            FetchFinished();

<# GetOldValueFromRegOrMem(reg); #>
<# if (instrType == "RLC") { #>
        var newValue = (byte)((oldValue << 1) | (oldValue >> 7));
            Registers.CF = oldValue.GetBit(7);
<# } else if (instrType == "RRC") { #>
        var newValue = (byte)((oldValue >> 1) | (oldValue << 7));
		    Registers.CF = oldValue.GetBit(0);
<# } #>
<# SetNewValueToRegOrMem(reg); #>

            Registers.HF = 0;
            Registers.NF = 0;
            SetFlags3and5From(newValue);
<# if (!isOldInstr) { #>
            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
			Registers.PF = Parity[newValue];

			return <#=isMemHL ? 15 : 8 #>;
<# } else { #>
            return 4;
<# } #>
        }

<# }} #>
	}
}
