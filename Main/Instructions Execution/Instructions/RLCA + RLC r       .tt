<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="_Utils.t4"#>
<#@ output extension=".cs" #>
<#AutoGeneratedCodeWarning(); #>

namespace Konamiman.Z80dotNet
{
    public partial class Z80InstructionExecutor
    {
<# foreach(var regName in new[] { "A", "B", "C", "D", "E", "H", "L", "(HL)", "" }) {
        var isOldInstr = (regName == "");
        var reg = isOldInstr ? "A" : regName;
        var isMemHL = (reg == "(HL)");
		var instrName = isOldInstr ? "RLCA" : "RLC " + reg;
		var methodName = isOldInstr ? "RLCA" : "RLC_" + (isMemHL ? "aHL" : reg); #>
		/// <summary>
        /// The <#=instrName#> instruction
        /// </summary>
        byte <#=methodName#>()
        {
            FetchFinished();

<# GetOldValueFromRegOrMem(reg); #>
        var newValue = (byte)((oldValue << 1) | (oldValue >> 7));
<# SetNewValueToRegOrMem(reg); #>

            Registers.CF = oldValue.GetBit(7);
            Registers.HF = 0;
            Registers.NF = 0;
            SetFlags3and5From(newValue);
<# if(!isOldInstr) { #>
            Registers.SF = newValue.GetBit(7);
            Registers.ZF = (newValue == 0);
			Registers.PF = Parity[newValue];

			return <#=isMemHL ? 15 : 8#>;
<# } else { #>
            return 4;
<# } #>
        }

<# } #>
	}
}
